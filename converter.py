#
# This script reads the existing C# files from the model and converts
# them, by way of several nasty regular expressions, into Python source
# files. It will overwrite the existing files in components/, so be
# careful before running it. Also, be advised that it expects to find
# the FUND model in ./fund, so be sure to download it from the GitHub
# repository and place it in the appropriate location.
# 

import re
import glob
import os
import warnings
import datetime
import sys

def convert_file(filename):
  new_name = "components/{0}.py".format(os.path.basename(filename)[:-3])
  
  source = open(filename).read()
  destination = open(new_name, 'w')
  result = [ ]
  
  result.append('''\
# This file was automatically generated by converter.py on
# {0}. Think long and hard before
# attempting to modify it.

import math
from components.helpers import *
from components._patches import *
'''.format(datetime.datetime.now()))
  
  behaviors_classes = [ ]
  
  def _class(match):
    found_any = [ True ]
    
    def _interface(match):
      all_parameters = [ ]
      
      result.append("class {0}(Parameters):".format(match.group(1)))
      
      index = match.group(0)[1:].find('interface')
      
      if index < 0:
        index = len(match.group(0))
      
      next_description = None
      
      def _ivariable(match):
        if match.group(1):
          desc = re.sub(r'(^//?/?)|(</?summary>)', '', match.group(1)).strip()
        else:
          desc = None # '[[{0}]]'.format(match.group(4))
        
        types = [ x.strip() for x in match.group(4).split(',') ]
        return_value = types.pop()
        
        result.append("   {4} = {1}({4!r}, {2!r}, {3!r}, {0!r})".format(desc, match.group(3), types, return_value, match.group(5)))
        
        all_parameters.append(match.group(5))
        
        return ""
      
      def _ivariable_scalar(match):
        if match.group(1):
          desc = re.sub(r'(^//?/?)|(</?summary>)', '', match.group(1)).strip()
        else:
          desc = None # '[[{0}]]'.format(match.group(4))
        
        result.append("   {0} = ScalarVariable({0!r}, {1!r}, {2!r})".format(match.group(4), match.group(3), desc))
        
        all_parameters.append(match.group(4))
        return ""
      
      found_any[0] = True
      
      chunk = match.group(0)[:index]
      chunk2 = re.sub(r'(//([^\r\n]*?)[ \t\r\n]+?)?(I[a-zA-Z0-9]+)<([^>]*?)> ([a-zA-Z0-9]+) {.*?}',
        _ivariable, chunk, flags = re.DOTALL)
      re.sub(r'(//([^\r\n]*?)[\r\n][ \t\r\n]+?)?[ \t]*([a-zA-Z0-9]+)[ \t]+([a-zA-Z0-9]+)[ \t]+{.*?}',
        _ivariable_scalar, chunk2, flags = re.MULTILINE)
      
      result.append("")
      result.append("   options = [ {0} ]".format(','.join(all_parameters)))
      return match.group(0)[index:]
    
    left = match.group(2)
    while found_any[0]:
      found_any[0] = False
      left = re.sub(r'interface ([A-Za-z0-9]+).*?{(.*)}.*?', _interface, left, flags = re.DOTALL)
    
    found_any = [ True ]
    
    def _run(match):
      index = match.group(0)[1:].find('public class')
      
      if index < 0:
        index = len(match.group(0))
      
      code = left[match.start(2) : min(match.end(2), match.start(0) + index) ]
      
      code = re.sub(r'[ \t\r\n]*{[ \t]*[\r\n]', ':\n', code)
      code = re.sub(r'}', '', code)
      code = re.sub(r'var ', '', code)
      code = re.sub(r'//.+', '', code)
      code = re.sub(r'/\*.*?\*/', '', code)
      code = re.sub(r'if ([^\r\n:]+)([\r\n])', r'if \1:\2', code)
      
      def _lambda(match):
        args = [ x.split(' ')[1].strip() for x in match.group(2).split(',') ]
        return "def {0}({1}):\n{2}".format(match.group(1), ', '.join(args), match.group(3))
          
      code = re.sub(r'([A-Za-z0-9]+)\s*=\s*Funcifier.Funcify\s*\(\s*\((.*?)\).*?:(.*?)[\r\n][ \t]*\)', _lambda, code, flags = re.DOTALL)
      code = re.sub(r'(\s+)=\s+([^;]+?);', r'\1= (\2);', code)
      code = re.sub(r'foreach \((.+?) in (.+?)\):', r'for \1 in \2:', code)
      code = re.sub(r'else\s*([\r\n])', r'else:\1', code)
      code = re.sub(r'Math\.(Abs|Max|Min)', lambda x: x.group(1).lower(), code)
      code = re.sub(r'Math\.[A-Za-z]+', lambda x: x.group(0).lower(), code)
      code = re.sub(r'throw\s+new', 'raise', code)
      code = re.sub(r'(\s+)(.+?):\s*[\r\n \t]*[\r\n]\1([^ \t\r\n])', r'\1\2:\n\1  pass\n\1\3', code)
      code = re.sub(r'[\r\n](\s+)(Double|double|float|int) ', r'\1', code)
      code = re.sub(r'GetValues<Region>', 'GetValuesOfRegion', code)
      code = re.sub(r'[dD]ouble.PositiveInfinity', 'float(\'+inf\')', code)
      code = re.sub(r'[dD]ouble.NegativeInfinity', 'float(\'-inf\')', code)
      code = re.sub(r'[dD]ouble.IsNaN', 'math.isnan', code)
      code = re.sub(r';[ \t]*(\r\n|\n)', '\n', code)
      code = re.sub(r'\s+\?\s+', ' and ', code)
      code = re.sub(r'\s+:\s+', ' or ', code)
      code = re.sub(r'else if', 'elif', code)
      code = re.sub(r'&&', 'and', code)
      code = re.sub(r'\|\|', 'or', code)
      code = re.sub(r'!', 'not ', code)
      code = re.sub(r'\(([^=(]+)=>(.+?)\)', r'(lambda \1:\2)', code)
      
      state_class = match.group(1)
      
      if state_class.endswith('Component'):
        state_class = state_class[:-len('Component')]
      
      behaviors_classes.append(match.group(1))
      
      result.append("class {0}(Behaviors):".format(match.group(1)))
      result.append("   state_class = I{0}State".format(state_class))
      result.append("   ")
      result.append("   def run(self, state, clock, dimensions):")
      result.append(code)
      
      found_any[0] = True
      
      return match.group(0)[index:]
    
    left = match.group(2)
    
    while found_any[0]:
      found_any[0] = False
      left = re.sub(r'public class ([A-Za-z0-9]+).*?{.*?public void Run.*?{(.*)}.*?}', _run, left, flags = re.DOTALL)
  
    return ""
  
  re.sub(r'namespace Fund\.Components\.([A-Za-z0-9]*).*?{(.*)}', _class, source, flags = re.DOTALL)

  result.append("\n\nbehavior_classes = [ {0} ]".format(', '.join(behaviors_classes)))
  
  generated_code = "\n".join(result)
  
  # print generated_code
  
  autopep8 = None
  
  try:
    import autopep8
  except ImportError:
    warnings.warn("You do not have autopep8 installed; the generated "
                  "code is going to be terribly mangled.")
  
  exec generated_code in globals()
  
  if autopep8:
    generated_code = autopep8.fix_string(generated_code)
    exec generated_code in globals()
  
  destination.write(generated_code)
  destination.close()

if not os.path.isdir('fund'):
  print('Unable to find the FUND model. Please download it and place it in ./fund,')
  print('in the root directory of the PyFUND project.')
  sys.exit(1)

for file in glob.glob('fund/FundComponents/*.cs'):
  convert_file(file)